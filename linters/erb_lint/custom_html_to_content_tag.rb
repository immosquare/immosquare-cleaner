# frozen_string_literal: true

require "prism"

module ERBLint
  module Linters
    ##============================================================##
    ## This linter detects HTML tags containing only a single ERB
    ## output statement and converts them to content_tag helpers.
    ##
    ## @example
    ## bad
    ##   <div class="card-title"><%= t("app.title") %></div>
    ##
    ## good
    ##   <%= content_tag(:div, t("app.title"), :class => "card-title") %>
    ##
    ##============================================================##
    class CustomHtmlToContentTag < Linter

      include LinterRegistry

      MSG = "Use content_tag helper instead of HTML tag with ERB output."

      ##============================================================##
      ## Void elements that cannot have content (self-closing tags)
      ##============================================================##
      VOID_ELEMENTS = [
        "area",
        "base",
        "br",
        "col",
        "command",
        "embed",
        "hr",
        "img",
        "input",
        "keygen",
        "link",
        "menuitem",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
      ].freeze

      ##============================================================##
      ## Methods that should not be converted to content_tag
      ## - render: partials should stay in HTML for readability
      ## - content_tag: prevents cascading on multiple erb_lint passes
      ##
      ## Note: If content_tag is removed from exclusions, additional
      ## logic is needed to prevent cascading conversions. The approach
      ## would be to check if the content_tag has HTML attributes
      ## (:class, :id) which indicates it was generated by us in a
      ## previous pass. See same_tag_content_tag? method pattern:
      ##   - content_tag(:div, x, :class => "y") → skip (generated)
      ##   - content_tag(:div, x) → allow (user-written)
      ##============================================================##
      EXCLUDED_METHODS = [
        "yield",
        "render_to_string",
        "render",
        "content_tag",
        "image_tag",
        "link_to"
      ].freeze

      ##============================================================##
      ## HTML tags that should not be converted to content_tag
      ## These tags are more readable as HTML (tables, etc.)
      ##============================================================##
      EXCLUDED_TAGS = [
        "html",
        "body",
        "th",
        "td",
        "tr",
        "thead",
        "tbody",
        "tfoot",
        "table",
        "caption",
        "colgroup"
      ].freeze

      ##============================================================##
      ## Form builder methods - if called on a receiver, skip conversion
      ## This detects form builders regardless of variable name (f, form, etc.)
      ## Example: <div><%= f.input(:name) %></div> should stay as-is
      ##============================================================##
      FORM_BUILDER_METHODS = [
        "input",
        "label",
        "text_field",
        "text_area",
        "password_field",
        "hidden_field",
        "file_field",
        "check_box",
        "radio_button",
        "select",
        "collection_select",
        "collection_check_boxes",
        "collection_radio_buttons",
        "grouped_collection_select",
        "date_select",
        "time_select",
        "datetime_select",
        "date_field",
        "time_field",
        "datetime_field",
        "datetime_local_field",
        "month_field",
        "week_field",
        "url_field",
        "email_field",
        "number_field",
        "range_field",
        "search_field",
        "telephone_field",
        "phone_field",
        "color_field",
        "submit",
        "button",
        "association",
        "input_field",
        "error",
        "hint",
        "full_error"
      ].freeze

      def run(processed_source)
        document = processed_source.ast
        children = document.children.to_a

        children.each_with_index do |child, index|
          ##============================================================##
          ## Look for opening tag (not closing, not void element)
          ##============================================================##
          next unless child&.type == :tag
          next if closing_tag?(child)

          tag_name = extract_tag_name(child)
          next if tag_name.nil?
          next if VOID_ELEMENTS.include?(tag_name.downcase)
          next if EXCLUDED_TAGS.include?(tag_name.downcase)

          ##============================================================##
          ## Check if next child is text containing only ERB output
          ##============================================================##
          next_child = children[index + 1]
          next unless next_child&.type == :text

          erb_node = extract_single_erb_output(next_child)
          next unless erb_node

          ##============================================================##
          ## Check if next-next child is the closing tag
          ##============================================================##
          closing_child = children[index + 2]
          next unless closing_child&.type == :tag
          next unless closing_tag?(closing_child)
          next unless extract_tag_name(closing_child) == tag_name

          ##============================================================##
          ## Extract ERB code and check if it should be skipped
          ##============================================================##
          erb_code = extract_erb_code(erb_node)
          next if excluded_method?(erb_code)

          ##============================================================##
          ## Build the content_tag replacement
          ##============================================================##
          attributes = extract_attributes(child)
          new_code = build_content_tag(tag_name, erb_code, attributes)

          ##============================================================##
          ## Calculate the full range from opening to closing tag
          ##============================================================##
          full_range = processed_source.to_source_range(
            child.loc.begin_pos...closing_child.loc.end_pos
          )

          add_offense(full_range, MSG, {:new_code => new_code})
        end
      end

      def autocorrect(_processed_source, offense)
        lambda do |corrector|
          corrector.replace(offense.source_range, offense.context[:new_code])
        end
      end

      private

      ##============================================================##
      ## Check if tag is a closing tag (has solidus as first child)
      ##============================================================##
      def closing_tag?(tag_node)
        tag_node.children.first&.type == :solidus
      end

      ##============================================================##
      ## Extract tag name from tag node
      ##============================================================##
      def extract_tag_name(tag_node)
        name_node = tag_node.children.find {|c| c&.type == :tag_name }
        name_node&.children&.first
      end

      ##============================================================##
      ## Extract single ERB output node from text node
      ## Returns nil if text contains anything other than whitespace
      ## and a single ERB output
      ##============================================================##
      def extract_single_erb_output(text_node)
        erb_nodes = []
        has_non_whitespace_text = false

        text_node.children.each do |child|
          if child.is_a?(String)
            has_non_whitespace_text = true unless child.match?(/\A\s*\z/)
          elsif child&.type == :erb
            erb_nodes << child
          end
        end

        return nil if has_non_whitespace_text
        return nil if erb_nodes.size != 1

        erb_node = erb_nodes.first
        ##============================================================##
        ## Must be output ERB (<%= ... %>) not statement (<% ... %>)
        ##============================================================##
        indicator = erb_node.children.first
        return nil unless indicator&.type == :indicator
        return nil unless indicator.children.first == "="

        erb_node
      end

      ##============================================================##
      ## Extract Ruby code from ERB node
      ##============================================================##
      def extract_erb_code(erb_node)
        code_node = erb_node.children.find {|c| c&.type == :code }
        code_node&.loc&.source&.strip
      end

      ##============================================================##
      ## Check if the ERB code calls an excluded method or form builder
      ## Uses Prism parser for proper Ruby AST analysis
      ##============================================================##
      def excluded_method?(erb_code)
        return false unless erb_code

        call_node = extract_call_node(erb_code)
        return false unless call_node

        method_name = call_node.name.to_s
        return true if EXCLUDED_METHODS.include?(method_name)

        ##============================================================##
        ## If method is a form builder method called on a receiver,
        ## skip conversion (e.g., f.input, form.text_field, etc.)
        ##============================================================##
        return true if call_node.receiver && FORM_BUILDER_METHODS.include?(method_name)

        false
      end

      ##============================================================##
      ## Extract the CallNode from Ruby code using Prism parser
      ## Handles both direct calls and calls with if/unless modifiers
      ##============================================================##
      def extract_call_node(erb_code)
        result = Prism.parse(erb_code)
        return nil unless result.success?

        node = result.value.statements.body.first

        ##============================================================##
        ## Handle if/unless modifiers: `render(...) if condition`
        ##============================================================##
        node = node.statements&.body&.first if node.is_a?(Prism::IfNode) || node.is_a?(Prism::UnlessNode)

        return nil unless node.is_a?(Prism::CallNode)

        node
      rescue StandardError
        nil
      end

      ##============================================================##
      ## Extract attributes from tag node as hash
      ##============================================================##
      def extract_attributes(tag_node)
        attrs = {}
        attrs_node = tag_node.children.find {|c| c&.type == :tag_attributes }
        return attrs unless attrs_node

        attrs_node.children.each do |attr|
          next unless attr&.type == :attribute

          name_node = attr.children.find {|c| c&.type == :attribute_name }
          value_node = attr.children.find {|c| c&.type == :attribute_value }

          name = name_node&.children&.first
          next unless name

          ##============================================================##
          ## Value can be a string or contain ERB
          ##============================================================##
          value = extract_attribute_value(value_node)
          attrs[name] = value
        end

        attrs
      end

      ##============================================================##
      ## Extract attribute value, handling both static and ERB values
      ## Returns a hash with :type (:static, :dynamic, :erb_only) and :value
      ##============================================================##
      def extract_attribute_value(value_node)
        return nil unless value_node

        parts = []
        erb_parts = []
        static_parts = []

        value_node.children.each do |child|
          if child.is_a?(String)
            parts << {:type => :static, :value => child}
            static_parts << child
          elsif child.respond_to?(:type)
            next if child.type == :quote

            if child.type == :erb
              erb_code = extract_erb_code(child)
              parts << {:type => :erb, :value => erb_code}
              erb_parts << erb_code
            end
          end
        end

        ##============================================================##
        ## Determine the attribute value type:
        ## - :erb_only: Only ERB, no static text (use Ruby directly)
        ## - :dynamic: Mix of static and ERB (use interpolation)
        ## - :static: Only static text (use quoted string)
        ##============================================================##
        if erb_parts.any? && static_parts.all? {|s| s.match?(/\A\s*\z/) }
          ##============================================================##
          ## Pure ERB value: class="<%= expr %>" -> :class => (expr)
          ##============================================================##
          {:type => :erb_only, :value => erb_parts.first}
        elsif erb_parts.any?
          ##============================================================##
          ## Mixed value: class="foo <%= expr %>" -> :class => "foo #{expr}"
          ##============================================================##
          combined = parts.map do |part|
            part[:type] == :erb ? "\#{#{part[:value]}}" : part[:value]
          end.join
          {:type => :dynamic, :value => combined}
        else
          ##============================================================##
          ## Static value: class="foo" -> :class => "foo"
          ##============================================================##
          {:type => :static, :value => static_parts.join}
        end
      end

      ##============================================================##
      ## Build content_tag call
      ## Handles if/unless modifiers by moving them outside content_tag
      ##============================================================##
      def build_content_tag(tag_name, content, attributes)
        ##============================================================##
        ## Extract modifier (if/unless) from content if present
        ##============================================================##
        content_part, modifier_part = extract_modifier(content)

        ##============================================================##
        ## Wrap content in parentheses if it's an ambiguous method call
        ## (method call without parentheses that has arguments)
        ##============================================================##
        wrapped_content = needs_parentheses?(content_part) ? "(#{content_part})" : content_part

        ##============================================================##
        ## Format tag name as symbol or string depending on characters
        ##============================================================##
        formatted_tag = format_tag_name(tag_name)

        if attributes.empty?
          base = "content_tag(#{formatted_tag}, #{wrapped_content})"
        else
          attrs_str = attributes.map do |name, attr_data|
            key = normalize_attribute_name(name)
            formatted_value = format_attribute_value(attr_data)
            "#{key} => #{formatted_value}"
          end.join(", ")

          base = "content_tag(#{formatted_tag}, #{wrapped_content}, #{attrs_str})"
        end

        if modifier_part
          "<%= #{base} #{modifier_part} %>"
        else
          "<%= #{base} %>"
        end
      end

      ##============================================================##
      ## Format tag name for content_tag
      ## - Simple tags (div, span) -> :div, :span
      ## - Tags with special chars (x-card) -> "x-card"
      ##============================================================##
      def format_tag_name(tag_name)
        if tag_name.match?(/\A[a-z_][a-z0-9_]*\z/i)
          ":#{tag_name}"
        else
          "\"#{tag_name}\""
        end
      end

      ##============================================================##
      ## Check if Ruby code needs parentheses when used as argument
      ## Returns true for method calls without parentheses that have
      ## arguments (which would be ambiguous in content_tag context)
      ## Example: "tag t('x'), path, :class => 'y'" needs parentheses
      ##============================================================##
      def needs_parentheses?(erb_code)
        return false unless erb_code

        result = Prism.parse(erb_code)
        return false unless result.success?

        node = result.value.statements.body.first
        return false unless node.is_a?(Prism::CallNode)

        ##============================================================##
        ## Check if it's a method call with arguments but no parentheses
        ##============================================================##
        has_arguments = node.arguments&.arguments&.any?
        return false unless has_arguments

        ##============================================================##
        ## Check if parentheses are missing by looking at the source
        ## If the method name is not immediately followed by '(', it
        ## needs wrapping
        ##============================================================##
        method_name = node.name.to_s
        source = erb_code.strip

        ##============================================================##
        ## Find position after method name (accounting for receiver)
        ##============================================================##
        if node.receiver
          ##============================================================##
          ## For calls like "tag.div" or "f.input", find the method call
          ##============================================================##
          call_loc = node.call_operator_loc || node.message_loc
          return false unless call_loc

          after_method = call_loc.end_offset + method_name.length
        else
          after_method = method_name.length
        end

        ##============================================================##
        ## Check if character after method name is '('
        ##============================================================##
        return false if after_method >= source.length

        source[after_method] != "("
      rescue StandardError
        false
      end

      ##============================================================##
      ## Format attribute value based on its type
      ## - :erb_only: Pure ERB -> (expr) with parentheses if needed
      ## - :dynamic: Mixed -> "text #{expr}" with interpolation
      ## - :static: Pure text -> "value" with proper quoting
      ##============================================================##
      def format_attribute_value(attr_data)
        return '""' if attr_data.nil?

        type = attr_data[:type]
        value = attr_data[:value]

        return '""' if value.nil? || value.empty?

        case type
        when :erb_only
          ##============================================================##
          ## Pure ERB: wrap in parentheses for safety
          ## class="<%= x if y %>" -> :class => (x if y)
          ##============================================================##
          "(#{value})"
        when :dynamic
          ##============================================================##
          ## Mixed static and ERB: use interpolation
          ## class="foo <%= bar %>" -> :class => "foo #{bar}"
          ##============================================================##
          quote_string_value(value, :allow_interpolation => true)
        else
          ##============================================================##
          ## Static value: simple quoting
          ##============================================================##
          quote_string_value(value, :allow_interpolation => false)
        end
      end

      ##============================================================##
      ## Quote a string value for Ruby output
      ## - Uses double quotes by default
      ## - Switches to single quotes if value contains double quotes
      ## - Keeps double quotes for interpolation
      ##============================================================##
      def quote_string_value(value, allow_interpolation: false)
        has_interpolation = value.include?('#{')
        has_double_quotes = value.include?('"')

        if has_interpolation && allow_interpolation
          ##============================================================##
          ## Must use double quotes for interpolation, escape inner quotes
          ##============================================================##
          escaped = value.gsub('"', '\\"')
          "\"#{escaped}\""
        elsif has_double_quotes
          ##============================================================##
          ## Use single quotes to avoid escaping
          ##============================================================##
          "'#{value}'"
        else
          "\"#{value}\""
        end
      end

      ##============================================================##
      ## Extract if/unless modifier from Ruby code
      ## Returns [content, modifier] or [content, nil]
      ## Example: "foo if bar" => ["foo", "if bar"]
      ##============================================================##
      def extract_modifier(erb_code)
        return [erb_code, nil] unless erb_code

        result = Prism.parse(erb_code)
        return [erb_code, nil] unless result.success?

        node = result.value.statements.body.first

        ##============================================================##
        ## Check for if/unless modifier
        ##============================================================##
        if node.is_a?(Prism::IfNode) || node.is_a?(Prism::UnlessNode)
          ##============================================================##
          ## Only handle modifier form (no else, single statement body)
          ##============================================================##
          if node.consequent.nil? && node.statements&.body&.size == 1
            keyword = node.is_a?(Prism::IfNode) ? "if" : "unless"
            condition = node.predicate.slice
            content = node.statements.body.first.slice
            return [content, "#{keyword} #{condition}"]
          end
        end

        [erb_code, nil]
      rescue StandardError
        [erb_code, nil]
      end

      ##============================================================##
      ## Normalize attribute name to Ruby symbol format
      ## class -> :class, data-value -> :\"data-value\" or data: { value: }
      ##============================================================##
      def normalize_attribute_name(name)
        if name.match?(/\A[a-z_][a-z0-9_]*\z/i)
          ":#{name}"
        else
          ":\"#{name}\""
        end
      end

    end
  end
end
